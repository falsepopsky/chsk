import { ArgsTable, Canvas, Meta, Source, Story } from '@storybook/addon-docs'
import { Chart, Axis, GridLines } from '@chsk/core'
import { ScatterInterval } from '../../src'
import { ChartForIntervalDecorator } from './decorators'

# ScatterInterval

<Meta title="Addons/XY/ScatterInterval" />
export const Template = args => <ScatterInterval {...args} />

`ScatterInterval` draws a polygon intended as an interval around a curve

<ArgsTable of={ScatterInterval} />

## Interval bounds

`ScatterInterval` shapes are characterized, for value along the x-axis, with a lower- and an upper value on the y-axis.
These bounds are extracted from data using keys set with props `lower` and `upper`.

<Canvas>
    <Story
        name="interval"
        args={{
            ids: ['A'],
            curve: 'Natural',
            lower: 'lo',
            upper: 'hi',
            style: { fill: '#dd4444', strokeWidth: 0, fillOpacity: 0.5 },
        }}
        component={ScatterInterval}
        decorators={[ChartForIntervalDecorator]}
    >
        {Template.bind({})}
    </Story>
</Canvas>

## Convolution and down-sampling

Similarly to `ScatterCurve`, ScatterInterval` accepts signal-processing props related to convolution and down-sampling.
The example below shows the same data as before, with a moving average of three points and down-sampling by a factor of 0.5.

<Canvas>
    <Story
        name="signal processing"
        args={{
            ids: ['A'],
            curve: 'Natural',
            lower: 'lo',
            upper: 'hi',
            style: { fill: '#dd4444', strokeWidth: 0, fillOpacity: 0.5 },
            convolutionMask: [1, 1, 1],
            downsampleFactor: 0.5,
        }}
        component={ScatterInterval}
        decorators={[ChartForIntervalDecorator]}
    >
        {Template.bind({})}
    </Story>
</Canvas>
